# ЭВМ

## Темы

1. [Каноническая функциональная структура ЭВМ Джона фон Неймана, архитектурные принципы](#1)  
2. [Варианты архитектур ЭВМ: принстонская и гарвардская. Их роли в современных ЭВМ](#варианты-архитектур-эвм-принстонская-и-гарвардская-их-роли-в-современных-эвм)  
3. [Варианты структур ЭВМ: иерархическая и магистральная](#варианты-структур-эвм-иерархическая-и-магистральная)  
4. [Классификация архитектур многопроцессорных вычислительных систем по Флинну](#классификация-архитектур-многопроцессорных-вычислительных-систем-по-флинну)  
5. [Многоуровневая модель функционирования ЭВМ](#многоуровневая-модель-функционирования-эвм)  
6. [Функциональная структура микропроцессора](#функциональная-структура-микропроцессора)  
7. [Краткая характеристика основных узлов](#краткая-характеристика-основных-узлов)  
8. [Операционные и управляющие автоматы](#операционные-и-управляющие-автоматы)  
9. [Синтез операционных автоматов канонической структуры](#синтез-операционных-автоматов-канонической-структуры)  
10. [Представление чисел в ЭВМ](#представление-чисел-в-эвм)  
11. [Алгоритмы умножения и деления, структура АЛУ умножения и деления](#алгоритмы-умножения-и-деления-структура-алу-умножения-и-деления)  
12. [Управляющие автоматы с жёсткой логикой: классификация, основные особенности](#управляющие-автоматы-с-жёсткой-логикой-классификация-основные-особенности)  
13. [Управляющие автоматы, построенные по схеме Мура, схеме Мили](#управляющие-автоматы-построенные-по-схеме-мура-схеме-мили)  
14. [Управляющие автоматы с хранимой в памяти логикой: принципы построения](#управляющие-автоматы-с-хранимой-в-памяти-логикой-принципы-построения)  
15. [Микропрограммирование, кодирование микрокоманд](#микропрограммирование-кодирование-микрокоманд)  
16. [Машинная арифметика](#машинная-арифметика)  
17. [Выбор оптимального алгоритма умножения и структуры устройства умножения](#выбор-оптимального-алгоритма-умножения-и-структуры-устройства-умножения)  
18. [Подходы к ускорению умножения](#подходы-к-ускорению-умножения)  
19. [Алгоритмы с восстановлением и без восстановления остатка](#алгоритмы-с-восстановлением-и-без-восстановления-остатка)  
20. [Простейшая микроархитектура процессора](#простейшая-микроархитектура-процессора)  
21. [Преимущества трёхшинной микроархитектуры](#преимущества-трёхшинной-микроархитектуры)  
22. [Предвыборка команд: принципы построения, алгоритм функционирования](#предвыборка-команд-принципы-построения-алгоритм-функционирования)  
23. [Микроархитектура с предвыборкой команд](#микроархитектура-с-предвыборкой-команд)  
24. [Простейшая конвейерная микроархитектура](#простейшая-конвейерная-микроархитектура)  
25. [Стадии простейшего 5-ти ступенчатого конвейера](#стадии-простейшего-5-ти-ступенчатого-конвейера)  
26. [Принцип суперскалярности](#принцип-суперскалярности)  
27. [Разновидности конфликтов при конвейерном исполнении команд и пути их преодоления](#разновидности-конфликтов-при-конвейерном-исполнении-команд-и-пути-их-преодоления)  
28. [Динамическое прогнозирование ветвлений](#динамическое-прогнозирование-ветвлений)  
29. [Переименование регистров](#переименование-регистров)  
30. [Внеочередное и спекулятивное выполнение команд](#внеочередное-и-спекулятивное-выполнение-команд)  
31. [Понятие об архитектуре набора команд процессора](#понятие-об-архитектуре-набора-команд-процессора)  
32. [Архитектура CISC: принципы построения, преимущества, недостатки, признаки](#архитектура-cisc-принципы-построения-преимущества-недостатки-признаки)  
33. [Архитектура RISC: принципы построения, преимущества, недостатки, признаки](#архитектура-risc-принципы-построения-преимущества-недостатки-признаки)  
34. [Архитектура VLIW: принципы построения, преимущества, недостатки](#архитектура-vliw-принципы-построения-преимущества-недостатки)  
35. [Группы команд: классификация и основные характеристики](#группы-команд-классификация-и-основные-характеристики)  
36. [Форматы команд: назначение полей](#форматы-команд-назначение-полей)  
37. [Режимы адресации: классификация и основные характеристики](#режимы-адресации-классификация-и-основные-характеристики)  
38. [Направления повышения производительности вычислений на уровне архитектуры системы команд: SIMD-расширения](#направления-повышения-производительности-вычислений-на-уровне-архитектуры-системы-команд-simd-расширения)  
39. [Статические БИС ЗУ: принципы построения, основные особенности и области применения](#статические-бис-зу-принципы-построения-основные-особенности-и-области-применения)  
40. [Динамические БИС ЗУ: принципы построения, основные особенности и области применения](#динамические-бис-зу-принципы-построения-основные-особенности-и-области-применения)  
41. [Повышение производительности устройств асинхронной динамической памяти](#повышение-производительности-устройств-асинхронной-динамической-памяти)  
42. [Повышение производительности устройств синхронной динамической памяти](#повышение-производительности-устройств-синхронной-динамической-памяти)  
43. [Расслоение памяти](#расслоение-памяти)  
44. [Принципы построения кэш-памяти с прямым отображением](#принципы-построения-кэш-памяти-с-прямым-отображением)  
45. [Принципы построения полностью ассоциативной кэш-памяти](#принципы-построения-полностью-ассоциативной-кэш-памяти)  
46. [Принципы построения частично ассоциативной кэш-памяти](#принципы-построения-частично-ассоциативной-кэш-памяти)  
47. [Проблема замещения: физически нереализуемые и реализуемые алгоритмы](#проблема-замещения-физически-нереализуемые-и-реализуемые-алгоритмы)  
48. [Проблема обеспечения целостности данных: алгоритмы сквозной, буферизованной сквозной и обратной записи](#проблема-обеспечения-целостности-данных-алгоритмы-сквозной-буферизованной-сквозной-и-обратной-записи)  
49. [Модели многоуровневой кэш-памяти](#модели-многоуровневой-кэш-памяти)  
50. [Сегментная организация памяти в защищенном режиме: принципы построения, дескрипторы и дескрипторные таблицы](#сегментная-организация-памяти-в-защищенном-режиме-принципы-построения-дескрипторы-и-дескрипторные-таблицы)  
51. [Сегментная организация памяти в защищенном режиме: принципы построения, схема получения линейного адреса](#сегментная-организация-памяти-в-защищенном-режиме-принципы-построения-схема-получения-линейного-адреса)  
52. [Защита памяти на уровне сегментов](#защита-памяти-на-уровне-сегментов)  
53. [Страничная организация памяти: назначение, принципы построения, схема получения физического адреса](#страничная-организация-памяти-назначение-принципы-построения-схема-получения-физического-адреса)  
54. [Защита памяти на уровне страниц](#защита-памяти-на-уровне-страниц)
55. [Управление задачами](#управление-задачами)  
56. [Прерывания и исключения: источники, порядок обработки](#прерывания-и-исключения-источники-порядок-обработки)  
57. [Организация таблицы прерываний в реальном и защищённом режимах работы процессора](#организация-таблицы-прерываний-в-реальном-и-защищённом-режимах-работы-процессора)  
58. [Стратегии замещения страниц в памяти](#стратегии-замещения-страниц-в-памяти)

---

## Ответы на вопросы

### 1. Каноническая функциональная структура ЭВМ Джона фон Неймана, архитектурные принципы

**Ответ:**  
Архитектура Джона фон Неймана основана на следующих принципах:  
1. **Двоичное кодирование информации** — данные и команды представлены в виде двоичных чисел.  
2. **Линейно-адресная организация памяти** — память состоит из ячеек фиксированной длины, каждая из которых имеет уникальный адрес.  
3. **Хранение данных и команд в одной памяти** — команды и данные хранятся в одной памяти, различие между ними определяется только способом их интерпретации.  
4. **Последовательное выполнение команд** — команды выполняются в порядке их расположения в памяти, если не указано иное.  
5. **Программное управление** — выполнение программы осуществляется с помощью команд, которые хранятся в памяти.  

[К содержанию](#темы)

---

### 2. Варианты архитектур ЭВМ: принстонская и гарвардская. Их роли в современных ЭВМ

**Ответ:**  
1. **Принстонская архитектура**:  
   - Использует общую память для хранения данных и команд.  
   - Простая в реализации, но имеет ограничение по производительности из-за конфликта доступа к памяти.  

2. **Гарвардская архитектура**:  
   - Разделяет память для данных и команд.  
   - Позволяет одновременно выполнять выборку команд и операций с данными, что увеличивает производительность.  

**Роль в современных ЭВМ:**  
Современные процессоры используют гибридный подход:  
- На уровне кэш-памяти первого уровня (L1) данные и команды разделены (гарвардская архитектура).  
- На уровне основной памяти используется объединенная память (принстонская архитектура).  

[К содержанию](#темы)

---

### 3. Варианты структур ЭВМ: иерархическая и магистральная

**Ответ:**  
1. **Иерархическая структура**:  
   - Организована в виде уровней памяти (регистры, кэш, оперативная память, внешняя память).  
   - Позволяет ускорить доступ к часто используемым данным.  

2. **Магистральная структура**:  
   - Использует общую шину для передачи данных между компонентами.  
   - Простая в реализации, но ограничена пропускной способностью шины.  

**Роль в современных ЭВМ:**  
- Иерархическая структура используется для повышения производительности за счет кэширования.  
- Магистральная структура применяется в системах с низкими требованиями к производительности.  

[К содержанию](#темы)

---

### 4. Классификация архитектур многопроцессорных вычислительных систем по Флинну

**Ответ:**  
Классификация Флинна основана на количестве потоков команд и данных:  
1. **SISD (Single Instruction, Single Data)** — один поток команд, один поток данных. Пример: классические фон-неймановские машины.  
2. **SIMD (Single Instruction, Multiple Data)** — один поток команд, несколько потоков данных. Пример: векторные процессоры.  
3. **MISD (Multiple Instruction, Single Data)** — несколько потоков команд, один поток данных. Пример: системы обработки сигналов.  
4. **MIMD (Multiple Instruction, Multiple Data)** — несколько потоков команд и данных. Пример: многопроцессорные системы.  

[К содержанию](#темы)

---

### 5. Многоуровневая модель функционирования ЭВМ

**Ответ:**  
Модель функционирования ЭВМ включает несколько уровней:  
1. **Аппаратный уровень** — физическое оборудование (процессор, память, устройства ввода-вывода).  
2. **Микропрограммный уровень** — управление работой процессора с помощью микрокоманд.  
3. **Уровень машинного языка** — выполнение программ, написанных на машинном языке.  
4. **Уровень операционной системы** — управление ресурсами компьютера.  
5. **Уровень языка ассемблера** — программирование с использованием мнемоник.  
6. **Уровень высокоуровневых языков** — программирование на языках, таких как C, Python и др.  

[К содержанию](#темы)

---

### 6. Функциональная структура микропроцессора

**Ответ:**  
Микропроцессор состоит из следующих компонентов:  
1. **Блок управления (БУ)** — отвечает за декодирование инструкций и управление другими компонентами.  
2. **Арифметико-логическое устройство (АЛУ)** — выполняет арифметические и логические операции.  
3. **Регистры** — используются для временного хранения данных и инструкций.  
4. **Шины** — обеспечивают передачу данных, адресов и управляющих сигналов между компонентами.  

[К содержанию](#темы)

---

### 7. Краткая характеристика основных узлов

**Ответ:**  
1. **Блок управления** — формирует управляющие сигналы, обеспечивает выборку и декодирование команд.  
2. **АЛУ** — выполняет арифметические и логические операции.  
3. **Регистры** — хранят промежуточные данные и результаты вычислений.  
4. **Шины** — передают данные, адреса и управляющие сигналы.  

[К содержанию](#темы)

---

### 8. Операционные и управляющие автоматы

**Ответ:**  
1. **Операционный автомат (ОА)**:  
   - Выполняет операции над данными.  
   - Состоит из регистров, АЛУ и логических схем.  

2. **Управляющий автомат (УА)**:  
   - Генерирует управляющие сигналы для выполнения операций.  
   - Реализуется на основе схем Мура или Мили.  

[К содержанию](#темы)

---

### 9. Синтез операционных автоматов канонической структуры

**Ответ:**  
Этапы синтеза операционного автомата:  
1. Построение регистров для хранения входных и выходных данных.  
2. Создание комбинационных схем для выполнения микроопераций.  
3. Формирование логических условий для управления операциями.  

[К содержанию](#темы)

---

### 10. Представление чисел в ЭВМ

**Ответ:**  
1. **Прямой код** — знак числа кодируется отдельным битом, остальные биты представляют модуль числа.  
2. **Обратный код** — для отрицательных чисел все биты модуля инвертируются.  
3. **Дополнительный код** — инвертируются все биты модуля, затем прибавляется 1.  

Дополнительный код используется чаще всего, так как упрощает выполнение арифметических операций.  

[К содержанию](#темы)

---

### 11. Алгоритмы умножения и деления, структура АЛУ умножения и деления

**Ответ:**  
Умножение и деление в АЛУ выполняется с использованием ряда шагов, включая сдвиг, маскирование и сложение (или вычитание).  

1. **Умножение**:
   - Умножение двух чисел может выполняться методом последовательного сдвига и сложения. Например, при двоичном умножении младший бит множителя определяет, требуется ли добавление множимого. После каждой итерации множитель сдвигается вправо, а множимое — влево.
   - Алгоритм Бута позволяет минимизировать количество операций путем анализа групп бит множителя, что повышает производительность.

2. **Деление**:
   - Деление выполняется с использованием последовательного вычитания делителя из делимого. При этом остаток анализируется на каждой итерации: если результат отрицательный, остаток восстанавливается (алгоритм деления с восстановлением остатка).
   - Для деления без восстановления остатка вместо восстановления остатка используется корректировка частного.

Структура АЛУ для выполнения этих операций включает:
- **Регистры** для хранения операндов и промежуточных результатов.
- **Сдвиговые регистры** для выполнения операций сдвига.
- **Сумматоры/вычитатели** для выполнения арифметических операций.

[К содержанию](#темы)

---

### 12. Управляющие автоматы с жёсткой логикой: классификация, основные особенности

**Ответ:**  
Управляющие автоматы с жёсткой логикой представляют собой фиксированные схемы, которые генерируют управляющие сигналы для выполнения операций.  

1. **Особенности**:
   - Логика работы автомата не может быть изменена без физической модификации схемы.
   - Высокая скорость работы за счёт отсутствия необходимости интерпретации микропрограмм.
   - Используются в RISC-процессорах, где требуется выполнение простых команд за минимальное время.

2. **Недостатки**:
   - Ограниченная гибкость: при изменении алгоритма требуется замена схемы.
   - Фиксированная система команд.

3. **Классификация**:
   - Автоматы Мура: выходные сигналы зависят только от текущего состояния.
   - Автоматы Мили: выходные сигналы зависят от текущего состояния и входных сигналов.

[К содержанию](#темы)

---

### 13. Управляющие автоматы, построенные по схеме Мура, схеме Мили

**Ответ:**  
Управляющие автоматы могут быть построены по двум основным схемам:  

1. **Схема Мура**:
   - Выходные сигналы зависят исключительно от текущего состояния автомата.
   - Более простая реализация, так как не требуется учитывать входные сигналы при формировании выходов.
   - Пример: автомат, управляющий светофором (на каждом состоянии фиксированы выходы — красный, жёлтый, зелёный).

2. **Схема Мили**:
   - Выходные сигналы зависят как от текущего состояния, так и от входных сигналов.
   - Гибкая, но более сложная схема.
   - Пример: автомат, реагирующий на внешние события (например, кнопки лифта).

[К содержанию](#темы)

---

### 14. Управляющие автоматы с хранимой в памяти логикой: принципы построения

**Ответ:**  
Управляющие автоматы с хранимой в памяти логикой используют запоминающее устройство для хранения последовательности управляющих сигналов.

1. **Принципы построения**:
   - Все необходимые управляющие сигналы (микрокоманды) хранятся в памяти.
   - Управляющий автомат генерирует последовательность адресов для выбора нужных микрокоманд.
   - Изменение алгоритма достигается путём изменения содержимого памяти, без модификации аппаратных схем.

2. **Преимущества**:
   - Гибкость: легко адаптируется к новым задачам.
   - Простота изменения логики.

[К содержанию](#темы)

---

### 15. Микропрограммирование, кодирование микрокоманд

**Ответ:**  
Микропрограммирование — это способ управления процессором с помощью микропрограмм, хранящихся в памяти.

1. **Кодирование микрокоманд**:
   - **Горизонтальное кодирование**: каждая микрокоманда управляет отдельным сигналом. Высокая гибкость, но требуется больше памяти.
   - **Вертикальное кодирование**: микрокоманды кодируются компактно, что экономит память, но требует сложной декодировки.

2. **Преимущества**:
   - Простота изменения логики процессора.
   - Возможность реализации сложных алгоритмов без изменения аппаратной части.

[К содержанию](#темы)

---

### 16. Машинная арифметика

**Ответ:**  
Машинная арифметика представляет собой выполнение математических операций (сложение, вычитание, умножение, деление) над числами, представленных в двоичном формате.

1. **Типы представления чисел**:
   - Прямой код: знак числа задаётся отдельным битом.
   - Обратный код: инверсия всех битов для отрицательных чисел.
   - Дополнительный код: используется чаще всего, так как упрощает операции.

2. **Особенности**:
   - Выполняется с фиксированной или плавающей точкой.
   - Переполнение и ошибки округления являются важными факторами.

[К содержанию](#темы)

---

### 17. Выбор оптимального алгоритма умножения и структуры устройства умножения

**Ответ:**  
При выборе алгоритма умножения важно учитывать баланс между скоростью выполнения и сложностью реализации.

1. **Методы умножения**:
   - Последовательное сложение сдвинутых чисел.
   - Алгоритм Бута: оптимизация путём минимизации количества операций.

2. **Структура устройства умножения**:
   - Используются регистры для хранения промежуточных результатов.
   - Сумматоры и сдвиговые регистры.

[К содержанию](#темы)

---

### 18. Подходы к ускорению умножения

**Ответ:**  
1. **Логические методы**:
   - Анализ групп бит множителя.
   - Уменьшение числа операций.

2. **Аппаратные методы**:
   - Использование параллельного выполнения операций.
   - Применение матричных умножителей.

[К содержанию](#темы)

---

### 19. Алгоритмы с восстановлением и без восстановления остатка

**Ответ:**  
Деление в ЭВМ может выполняться с восстановлением или без восстановления остатка.  

1. **Алгоритм с восстановлением остатка**:  
   - После каждой итерации деления проверяется знак результата.  
   - Если результат отрицательный, то остаток восстанавливается, добавляя делитель обратно.  
   - Такой алгоритм обеспечивает точность, но требует дополнительных операций для восстановления остатка.  

   **Шаги алгоритма с восстановлением остатка**:  
   1. Делитель размещается в старших разрядах.  
   2. Проверяется возможность деления (остаток должен быть больше или равен делителю).  
   3. Если остаток меньше делителя, то выполняется восстановление, добавляя делитель обратно.  
   4. Остаток сдвигается влево, и вычитание повторяется до завершения всех итераций.  

2. **Алгоритм без восстановления остатка**:  
   - Восстановление остатка не производится, вместо этого результат корректируется на следующем шаге.  
   - Это снижает количество операций, но может быть менее точным для промежуточных результатов.  

   **Шаги алгоритма без восстановления остатка**:  
   1. Делитель размещается в старших разрядах.  
   2. Выполняется вычитание делителя из делимого.  
   3. Остаток анализируется: если результат отрицательный, то следующая цифра частного устанавливается в 0, иначе — в 1.  
   4. Остаток сдвигается влево, и процесс повторяется.  

Оба алгоритма активно применяются в современных процессорах в зависимости от требований к точности и производительности.  

[К содержанию](#темы)

---

### 20. Простейшая микроархитектура процессора

**Ответ:**  
Простейшая микроархитектура процессора представляет собой базовую структуру, обеспечивающую выполнение команд. Она состоит из следующих компонентов:  

1. **Шина данных** — обеспечивает передачу данных между процессором, памятью и устройствами ввода-вывода.  
2. **Шина адреса** — передаёт адреса данных или команд.  
3. **Блок управления (БУ)** — отвечает за декодирование инструкций и управление работой остальных компонентов.  
4. **Арифметико-логическое устройство (АЛУ)** — выполняет арифметические и логические операции.  
5. **Регистры** — обеспечивают временное хранение данных и результатов операций.  

**Принципы работы**:  
- Процессор выполняет команды последовательно, извлекая их из памяти.  
- Команда проходит через стадии выборки, декодирования и выполнения.  
- Операнды извлекаются из регистров или памяти, обрабатываются в АЛУ, а результат возвращается в регистры или записывается в память.  

**Преимущества**:  
- Простота реализации.  
- Низкая стоимость.  

**Недостатки**:  
- Ограниченная производительность из-за последовательного выполнения операций.  

[К содержанию](#темы)

---

### 21. Преимущества трёхшинной микроархитектуры

**Ответ:**  
Трёхшинная микроархитектура процессора предназначена для повышения производительности за счёт разделения потоков данных и адресов. Она включает три независимые шины:  

1. **Шина адреса программ** — используется для выборки команд.  
2. **Две шины данных** — для одновременной выборки двух операндов.  

**Преимущества трёхшинной микроархитектуры**:  
- **Увеличение производительности**:  
  - Одновременное выполнение операций считывания двух операндов и записи результата.  
  - Возможность выполнения сложных операций, таких как умножение, за один машинный цикл.  
- **Сокращение времени выполнения команд**:  
  - Для каждой команды выполняются параллельные операции — выборка команды, выборка операндов и запись результата.  

**Пример работы**:  
- За один машинный цикл процессор может:  
  1. Выбрать следующую команду.  
  2. Считать два операнда из памяти.  
  3. Выполнить операцию (например, умножение).  
  4. Сохранить результат в памяти.  

**Реализация**:  
Трёхшинная архитектура особенно эффективна для сигнальных процессоров, где требуется высокая скорость обработки данных.  

[К содержанию](#темы)

---

### 22. Предвыборка команд: принципы построения, алгоритм функционирования

**Ответ:**  
Предвыборка команд используется для повышения производительности процессора путем заблаговременного извлечения инструкций из памяти.  

1. **Принципы построения**:  
   - Используется кэш инструкций и буфер предвыборки для хранения заранее извлеченных команд.  
   - Организуется поток данных от памяти к процессору, чтобы минимизировать задержки при выполнении команд.  

2. **Алгоритм функционирования**:  
   - Процессор анализирует поток команд и предсказывает, какие инструкции будут выполнены в будущем.  
   - Эти команды извлекаются из памяти и помещаются в буфер предвыборки.  
   - Если предсказание ветвления оказывается неверным, буфер очищается, и процессор извлекает команды заново.  

**Пример**:  
Для одноадресной команды требуется два обращения к памяти: первое — для выборки команды, второе — для получения операнда. Предвыборка позволяет заранее извлечь следующую команду, пока текущая выполняется.  

[К содержанию](#темы)

---

### 23. Микроархитектура с предвыборкой команд

**Ответ:**  
Микроархитектура с предвыборкой команд — это структура процессора, в которой используются механизмы заблаговременного извлечения и хранения команд для выполнения.  

1. **Компоненты**:  
   - **Кэш инструкций** — хранит ранее извлеченные команды, чтобы минимизировать обращения к ОЗУ.  
   - **Буфер предвыборки** — временное хранилище для команд, предсказанных к выполнению.  
   - **Модуль предсказания ветвлений** — определяет вероятную последовательность команд.  

2. **Особенности работы**:  
   - Предвыборка команд снижает время простоя процессора.  
   - Улучшает производительность на уровнях конвейера и при выполнении ветвлений.  

[К содержанию](#темы)

---

### 24. Простейшая конвейерная микроархитектура

**Ответ:**  
Конвейерная микроархитектура позволяет процессору выполнять несколько команд одновременно, разделяя их выполнение на этапы.  

1. **Основные этапы конвейера**:  
   - **Выборка**: извлечение команды из памяти.  
   - **Декодирование**: анализ команды для определения операции и операндов.  
   - **Выполнение**: выполнение операции (например, сложение).  
   - **Доступ к памяти**: чтение или запись данных.  
   - **Запись результата**: сохранение результата в регистр или память.  

2. **Преимущества**:  
   - Увеличение производительности благодаря параллельному выполнению операций.  
   - Сокращение времени выполнения программ.  

3. **Недостатки**:  
   - Конфликты данных или управления могут замедлить процесс.  

[К содержанию](#темы)

---

### 25. Стадии простейшего 5-ти ступенчатого конвейера

**Ответ:**  
Простейший 5-ти ступенчатый конвейер состоит из следующих этапов:  

1. **Выборка команды (Fetch)**: извлечение инструкции из памяти.  
2. **Декодирование команды (Decode)**: определение операции и операндов команды.  
3. **Выполнение (Execute)**: выполнение арифметико-логических операций.  
4. **Доступ к памяти (Memory Access)**: чтение или запись данных в память.  
5. **Запись результата (Write Back)**: сохранение результата в регистр или память.  

**Пример работы**:  
Если одна команда находится на этапе выполнения, следующая команда может быть на этапе декодирования, а третья — на этапе выборки.  

[К содержанию](#темы)

---

### 26. Принцип суперскалярности

**Ответ:**  
Суперскалярность — это архитектурный принцип, при котором процессор может выполнять несколько инструкций одновременно за счет наличия нескольких исполнительных блоков.  

1. **Особенности**:  
   - Наличие нескольких АЛУ, модулей доступа к памяти и других функциональных блоков.  
   - Параллельное выполнение арифметических, логических и загрузочных операций.  

2. **Преимущества**:  
   - Значительное увеличение производительности.  
   - Эффективное использование ресурсов процессора.  

[К содержанию](#темы)

---

### 27. Разновидности конфликтов при конвейерном исполнении команд и пути их преодоления

**Ответ:**  
1. **Типы конфликтов**:  
   - **Структурные конфликты**: возникают, когда несколько команд пытаются использовать один и тот же ресурс.  
   - **Конфликты данных**: происходят, если команда зависит от результата предыдущей команды.  
   - **Конфликты управления**: связаны с ветвлениями, которые изменяют поток выполнения.  

2. **Пути преодоления**:  
   - Структурные конфликты: добавление дополнительных функциональных блоков.  
   - Конфликты данных: использование переадресации данных или задержек.  
   - Конфликты управления: предсказание ветвлений и спекулятивное выполнение команд.  

[К содержанию](#темы)

---

### 28. Динамическое прогнозирование ветвлений

**Ответ:**  
Динамическое прогнозирование ветвлений — это метод, позволяющий процессору предсказать, какая ветвь будет выполнена, до завершения команды ветвления.  

1. **Механизмы**:  
   - **Таблица истории ветвлений (Branch History Table)**: хранит информацию о предыдущих ветвлениях.  
   - **Двухбитовая схема предсказания**: уменьшает число ошибок за счет учета нескольких переходов.  

2. **Преимущества**:  
   - Уменьшение задержек в конвейере.  
   - Увеличение производительности за счет сокращения простоев.  

[К содержанию](#темы)

---

### 29. Переименование регистров

**Ответ:**  
Переименование регистров используется для устранения ложных зависимостей между командами в суперскалярных процессорах.  

1. **Принципы**:  
   - Использование физических регистров вместо логических.  
   - Таблица переименования регистров сопоставляет логические регистры с физическими.  

2. **Преимущества**:  
   - Устранение конфликтов при доступе к регистрам.  
   - Повышение параллелизма выполнения команд.  

[К содержанию](#темы)

---

### 30. Внеочередное и спекулятивное выполнение команд

**Ответ:**  
Внеочередное и спекулятивное выполнение команд — это два ключевых механизма, используемых в современных процессорах для увеличения производительности за счёт параллельной обработки инструкций и минимизации простоев.  

1. **Внеочередное выполнение (Out-of-Order Execution)**:  
   - Позволяет процессору выполнять команды не в порядке их поступления, а в зависимости от доступности данных и ресурсов.  
   - Процессор анализирует зависимости между инструкциями, чтобы избежать конфликтов данных, и выполняет независимые инструкции, пока ожидаются результаты других операций.  
   - Пример: Если инструкция А ожидает завершения операции, процессор может выполнить инструкции B и C, которые не зависят от результата А.  

   **Преимущества**:
   - Сокращение времени простоя процессора.  
   - Более эффективное использование вычислительных ресурсов.  

2. **Спекулятивное выполнение (Speculative Execution)**:  
   - Процессор предсказывает, какая ветвь программы будет выполнена (например, в случае ветвлений) и начинает выполнение этой ветки до подтверждения правильности предсказания.  
   - Если предсказание верно, результаты сохраняются. Если предсказание неверно, выполненные команды отменяются, и процессор возвращается к правильной ветви.  

   **Преимущества**:
   - Снижение задержек при ветвлениях.  
   - Ускорение выполнения программ с большим количеством условий.  

**Связь с предсказанием ветвлений**:  
Спекулятивное выполнение часто используется совместно с механизмами предсказания ветвлений, такими как таблицы истории переходов, которые помогают процессору предсказывать, какую ветвь программы необходимо выполнить.  

**Пример работы**:  
Допустим, программа имеет условие `if (x > y)`. Процессор может предсказать, что условие истинно, и начать выполнение ветви `if`. Если предсказание подтверждается, то выполнение продолжается без задержек. В противном случае процессор откатывает изменения.  

[К содержанию](#темы)

---

### 31. Понятие об архитектуре набора команд процессора

**Ответ:**  
Архитектура набора команд процессора (Instruction Set Architecture, ISA) — это описание того, как процессор взаимодействует с программным обеспечением. ISA определяет правила, форматы и инструкции, которые процессор может выполнять.  

1. **Основные элементы ISA**:
   - **Набор инструкций** — перечень команд, которые может выполнить процессор (например, арифметические, логические, команды ввода-вывода).  
   - **Форматы инструкций** — определяют структуру команды: поля для кода операции, операндов и т.д.  
   - **Режимы адресации** — способы определения местоположения данных в памяти (например, прямая, косвенная, индексная адресация).  
   - **Типы данных** — поддерживаемые процессором форматы данных (целочисленные, вещественные, текстовые и др.).  
   - **Регистры** — количество и назначение регистров, доступных для операций.  

2. **Роль ISA**:  
ISA является интерфейсом между аппаратным обеспечением и программным обеспечением. Оно определяет, как программное обеспечение взаимодействует с процессором, и обеспечивает совместимость между различными реализациями процессоров.  

3. **Пример ISA**:  
Архитектура x86 поддерживает такие инструкции, как `MOV` (перемещение данных), `ADD` (сложение), `CMP` (сравнение). Она также включает сложные инструкции, такие как `DIV` (деление) и `MUL` (умножение).  

4. **Связь с микроархитектурой**:  
ISA описывает функциональность процессора, тогда как микроархитектура определяет, как именно процессор реализует эту функциональность (например, с использованием конвейеров, кэшей и т.д.).  

[К содержанию](#темы)

---

### 32. Архитектура CISC: принципы построения, преимущества, недостатки, признаки

**Ответ:**  
CISC (Complex Instruction Set Computing) — это архитектура процессоров с большим набором сложных инструкций.  

1. **Принципы построения**:  
   - Процессоры CISC содержат богатый набор инструкций, каждая из которых может выполнять сложные операции (например, извлечение корня, обработка массивов).  
   - Одна инструкция может включать несколько этапов выполнения (например, выборка данных, выполнение операции, запись результата).  
   - Используются сложные схемы декодирования инструкций.  

2. **Преимущества**:  
   - Упрощение программирования: разработчикам не нужно разрабатывать сложные последовательности инструкций для выполнения сложных операций.  
   - Компактный код: одна команда может заменить множество простых команд.  

3. **Недостатки**:  
   - Сложность реализации: декодирование и выполнение сложных инструкций требует больше аппаратных ресурсов.  
   - Низкая производительность для простых операций из-за необходимости обработки сложных инструкций.  
   - Зависимость от частоты, так как выполнение сложных инструкций требует больше тактов.  

4. **Признаки CISC**:  
   - Большое количество инструкций (сотни или тысячи).  
   - Наличие сложных инструкций, таких как деление или извлечение корня.  
   - Поддержка различных режимов адресации (например, прямая, косвенная).  
   - Использование микрокода для реализации инструкций.  

5. **Пример CISC-процессоров**:  
   - Процессоры семейства Intel x86 (например, 8086, Pentium).  
   - Процессоры семейства Motorola 68000.  

CISC-архитектура широко использовалась в ранних процессорах, но с появлением RISC-архитектуры (с упрощённым набором команд) начала утрачивать своё доминирование.  

[К содержанию](#темы)

### 33. Архитектура RISC: принципы построения, преимущества, недостатки, признаки

**Ответ:**  
RISC (Reduced Instruction Set Computing) — это архитектура, которая фокусируется на сокращении набора команд для повышения производительности за счет более быстрого их выполнения.  

1. **Принципы построения**:  
   - Использование небольшого набора простых инструкций.  
   - Каждая инструкция выполняется за один такт процессора.  
   - Акцент на аппаратную реализацию инструкций и минимизацию программной сложности.  
   - Упрощение декодирования инструкций.  

2. **Преимущества**:  
   - Высокая производительность за счет сокращения времени выполнения команд.  
   - Упрощение архитектуры процессора.  
   - Возможность работы на высокой тактовой частоте.  

3. **Недостатки**:  
   - Необходимость большего количества инструкций для выполнения сложных операций.  
   - Сложность программирования на низком уровне.  

4. **Признаки**:  
   - Одиночный цикл на выполнение команды.  
   - Наличие большого числа регистров.  
   - Использование команд фиксированной длины.  

[К содержанию](#темы)

---

### 34. Архитектура VLIW: принципы построения, преимущества, недостатки

**Ответ:**  
VLIW (Very Long Instruction Word) — архитектура, в которой одна инструкция содержит несколько операций, выполняемых параллельно.  

1. **Принципы построения**:  
   - Компилятор отвечает за анализ и планирование выполнения команд.  
   - Каждая инструкция состоит из нескольких операций, которые выполняются одновременно.  
   - Упрощение аппаратной реализации за счет передачи ответственности за оптимизацию компилятору.  

2. **Преимущества**:  
   - Гарантированная загрузка нескольких функциональных блоков.  
   - Высокая производительность при выполнении параллельных операций.  

3. **Недостатки**:  
   - Низкая обратная совместимость программного обеспечения.  
   - Сложность программирования и разработки компиляторов.  
   - Повышенная сложность управления памятью.  

[К содержанию](#темы)

---

### 35. Группы команд: классификация и основные характеристики

**Ответ:**  
Группы команд процессора классифицируются по выполняемым операциям и их характеристикам.  

1. **Классификация**:  
   - **Арифметические команды**: сложение, вычитание, умножение, деление.  
   - **Логические команды**: AND, OR, XOR, NOT.  
   - **Команды передачи данных**: чтение, запись, перемещение данных.  
   - **Команды управления**: переходы, вызовы подпрограмм, возвраты.  

2. **Основные характеристики**:  
   - **Длина инструкции**: фиксированная или переменная.  
   - **Количество операндов**: от одного до трех операндов.  
   - **Режимы адресации**: прямой, косвенный, индексный.  

[К содержанию](#темы)

---

### 36. Форматы команд: назначение полей

**Ответ:**  
Форматы команд определяют структуру инструкции процессора и включают следующие поля:  

1. **КОП** (код операции): определяет выполняемую операцию.  
2. **Операнды**: содержат адреса или значения данных для операции.  
3. **Режим адресации**: указывает способ доступа к операндам.  
4. **Данные**: непосредственно включают значения, используемые в инструкции.  

**Пример**:  
Команда `ADD R1, R2, R3` означает сложение значений регистров R2 и R3 с сохранением результата в R1.  

[К содержанию](#темы)

---

### 37. Режимы адресации: классификация и основные характеристики

**Ответ:**  
Режимы адресации определяют, как процессор интерпретирует адреса операндов в командах.  

1. **Классификация**:  
   - **Прямая адресация**: адрес операнда указан явно.  
   - **Косвенная адресация**: адрес операнда хранится по указанному адресу.  
   - **Непосредственная адресация**: операнд задан прямо в команде.  
   - **Индексная адресация**: адрес вычисляется как сумма базового адреса и смещения.  

2. **Характеристики**:  
   - Простота реализации.  
   - Гибкость в обработке массивов и указателей.  
   - Использование различных способов доступа к данным.  

[К содержанию](#темы)

---

### 38. Направления повышения производительности вычислений на уровне архитектуры системы команд: SIMD-расширения

**Ответ:**  
SIMD (Single Instruction Multiple Data) — это архитектурный подход, при котором одна операция выполняется одновременно над несколькими элементами данных.  

1. **Принципы**:  
   - Использование векторных регистров для одновременной обработки нескольких данных.  
   - Выполнение одной инструкции над множеством данных.  

2. **Преимущества**:  
   - Ускорение вычислений за счет параллельной обработки.  
   - Эффективность при работе с массивами данных.  

3. **Применение**:  
   - Графические вычисления.  
   - Обработка сигналов и изображений.  

[К содержанию](#темы)

---

### 39. Статические БИС ЗУ: принципы построения, основные особенности и области применения

**Ответ:**  
Статические БИС ЗУ (SRAM) используют триггеры для хранения данных.  

1. **Принципы построения**:  
   - Каждая ячейка памяти представляет собой триггер.  
   - Информация сохраняется до тех пор, пока подается питание.  

2. **Особенности**:  
   - Высокое быстродействие.  
   - Устойчивость к внешним воздействиям.  
   - Высокая стоимость и энергопотребление.  

3. **Области применения**:  
   - Кэш-память процессоров.  
   - Буферная память.  

[К содержанию](#темы)

---

### 40. Динамические БИС ЗУ: принципы построения, основные особенности и области применения

**Ответ:**  
Динамические БИС ЗУ (DRAM) — это память с произвольным доступом, в основе которой лежат элементы памяти, выполненные в виде конденсаторов.  

1. **Принципы построения**:  
   - Каждая ячейка памяти состоит из транзистора и конденсатора.  
   - Конденсатор хранит заряд, который интерпретируется как бит данных (заряженный — 1, разряженный — 0).  
   - Со временем заряды конденсаторов утрачиваются, поэтому необходима периодическая регенерация данных.  

2. **Особенности**:  
   - Высокая плотность размещения ячеек памяти.  
   - Низкая стоимость по сравнению со статической памятью (SRAM).  
   - Требуется регулярная регенерация данных для предотвращения их утраты.  

3. **Области применения**:  
   - Используется в качестве оперативной памяти (ОЗУ) в компьютерах.  
   - Применяется в видеопамяти.  

[К содержанию](#темы)

---

### 41. Повышение производительности устройств асинхронной динамической памяти

**Ответ:**  
Асинхронная динамическая память (DRAM) работает без синхронизации с тактовыми сигналами процессора, что может снижать её производительность. Для её ускорения применяются следующие подходы:  

1. **Использование EDO RAM (Extended Data Out RAM)**:  
   - Позволяет извлекать данные быстрее, так как данные остаются доступными на выходной линии дольше.  

2. **Использование BEDO DRAM (Burst EDO RAM)**:  
   - Обеспечивает поблочное чтение данных, что ускоряет передачу больших объемов данных.  

3. **Улучшение управления регенерацией**:  
   - Регенерация данных выполняется только для тех строк, которые активно используются, что снижает задержки.  

4. **Снижение времени доступа**:  
   - Оптимизация схем обращения к памяти для ускорения выборки данных.  

Асинхронная память используется реже в современных системах, уступая место синхронным типам памяти.  

[К содержанию](#темы)

---

### 42. Повышение производительности устройств синхронной динамической памяти

**Ответ:**  
Синхронная динамическая память (SDRAM) синхронизирована с тактовыми сигналами процессора, что позволяет добиться более высокой производительности. Основные методы её ускорения:  

1. **Использование DDR SDRAM**:  
   - DDR (Double Data Rate) позволяет передавать данные дважды за один тактовый цикл (по фронту и спаду сигнала).  
   - Увеличивает пропускную способность памяти вдвое без повышения тактовой частоты.  

2. **Двухканальный режим работы**:  
   - Использование двух независимых каналов для чтения/записи данных.  
   - Позволяет удвоить пропускную способность.  

3. **Пакетная обработка данных**:  
   - Ускоряет последовательный доступ к данным за счёт обработки блоками (Burst Mode).  

4. **Оптимизация регенерации**:  
   - Более эффективное управление циклами регенерации данных для уменьшения задержек.  

Эти методы делают SDRAM основным типом оперативной памяти в современных компьютерах.  

[К содержанию](#темы)

---

### 43. Расслоение памяти

**Ответ:**  
Расслоение памяти — это метод организации памяти, при котором её пространство разбивается на несколько независимых слоёв (банков), что позволяет одновременно обращаться к разным частям данных.  

1. **Принципы построения**:  
   - Память делится на банки, каждый из которых может обрабатываться независимо.  
   - Адрес памяти разбивается на два поля: номер банка и смещение внутри банка.  

2. **Преимущества**:  
   - Значительное увеличение пропускной способности памяти.  
   - Одновременный доступ к нескольким данным, что особенно эффективно при выполнении операций с массивами.  
   - Снижение времени ожидания при выполнении последовательных операций.  

3. **Пример использования**:  
   - Расслоение активно применяется в многопроцессорных системах и в суперкомпьютерах для ускорения вычислений.  
   - Используется в видеопамяти для одновременной обработки нескольких потоков данных.  

[К содержанию](#темы)

---

### 44. Принципы построения кэш-памяти с прямым отображением

**Ответ:**  
Кэш-память с прямым отображением делит оперативную память на блоки и использует фиксированное соответствие между блоками оперативной памяти и кэш-памяти.  

1. **Принципы работы**:  
   - Каждый блок оперативной памяти может быть загружен только в определенный блок кэш-памяти.  
   - Адрес памяти разделяется на три части: тег, индекс и смещение. Индекс указывает строку кэш-памяти, куда может быть загружен блок, а тег используется для проверки совпадения.  

2. **Преимущества**:  
   - Простота реализации.  
   - Низкая стоимость.  

3. **Недостатки**:  
   - Возможны частые конфликты из-за фиксированной привязки блоков памяти к кэш-памяти.  

[К содержанию](#темы)

---

### 45. Принципы построения полностью ассоциативной кэш-памяти

**Ответ:**  
Полностью ассоциативная кэш-память позволяет загружать любой блок оперативной памяти в любой блок кэш-памяти.  

1. **Принципы работы**:  
   - Тег каждого блока памяти хранится в кэш-памяти.  
   - При поиске данных сравниваются все теги для проверки наличия блока в кэше.  

2. **Преимущества**:  
   - Минимизация конфликтов при замещении блоков.  

3. **Недостатки**:  
   - Сложность реализации из-за необходимости сравнивать теги всех блоков.  
   - Более высокая стоимость.  

[К содержанию](#темы)

---

### 46. Принципы построения частично ассоциативной кэш-памяти

**Ответ:**  
Частично ассоциативная кэш-память является компромиссом между прямым отображением и полностью ассоциативной кэш-памятью.  

1. **Принципы работы**:  
   - Кэш-память разбивается на несколько наборов (модулей).  
   - Каждый блок оперативной памяти может быть загружен только в определенный набор, но внутри набора он может быть загружен в любой блок.  

2. **Преимущества**:  
   - Уменьшается вероятность конфликтов по сравнению с прямым отображением.  
   - Простота реализации по сравнению с полностью ассоциативной кэш-памятью.  

3. **Недостатки**:  
   - Более сложная реализация, чем у кэш-памяти с прямым отображением.  

[К содержанию](#темы)

---

### 47. Проблема замещения: физически нереализуемые и реализуемые алгоритмы

**Ответ:**  
Проблема замещения возникает, когда кэш-память заполнена, и необходимо выбрать блок для замены.

1. **Физически нереализуемые алгоритмы**:  
   - Замена блока, который будет использоваться позже других. Этот алгоритм требует предсказания будущего доступа, что невозможно.  

2. **Физически реализуемые алгоритмы**:  
   - **FIFO (First In First Out)**: замещается блок, который дольше всех находился в кэше.  
   - **LRU (Least Recently Used)**: замещается блок, который дольше всего не использовался.  
   - **Random**: случайный выбор блока для замещения.  
   - **LFU (Least Frequently Used)**: замещается блок, который использовался реже всего.  

[К содержанию](#темы)

---

### 48. Проблема обеспечения целостности данных: алгоритмы сквозной, буферизованной сквозной и обратной записи

**Ответ:**  
Целостность данных в кэш-памяти подразумевает синхронизацию содержимого кэша и оперативной памяти.  

1. **Алгоритмы обновления**:  
   - **Сквозная запись (Write-Through)**: данные одновременно записываются в кэш и оперативную память.  
   - **Буферизованная сквозная запись (Buffered Write-Through)**: данные записываются в кэш и промежуточный буфер, а из буфера — в оперативную память.  
   - **Обратная запись (Write-Back)**: данные записываются только в кэш, а в оперативную память — только при замещении блока.  

[К содержанию](#темы)

---

### 49. Модели многоуровневой кэш-памяти

**Ответ:**  
Многоуровневая кэш-память используется для повышения производительности современных процессоров.  

1. **Уровни кэш-памяти**:  
   - **L1 (первый уровень)**: малая ёмкость, высокая скорость.  
   - **L2 (второй уровень)**: больше ёмкость, ниже скорость.  
   - **L3 (третий уровень)**: общая для всех ядер, большая ёмкость, самая низкая скорость среди кэшей.  

2. **Модели:**  
   - **Инклюзивная модель**: данные из верхнего уровня кэша дублируются в нижележащих.  
   - **Эксклюзивная модель**: данные на каждом уровне уникальны.  

[К содержанию](#темы)

---

### 50. Сегментная организация памяти в защищенном режиме: принципы построения, дескрипторы и дескрипторные таблицы

**Ответ:**  
Сегментная организация памяти делит адресное пространство на сегменты, каждому из которых соответствует дескриптор.  

1. **Принципы построения**:  
   - Память делится на сегменты (код, данные, стек).  
   - Доступ к сегментам управляется дескрипторами, хранящимися в таблицах (GDT, LDT).  

2. **Дескрипторы**:  
   - Описывают базовый адрес сегмента, его размер, права доступа и другие атрибуты.  

[К содержанию](#темы)

---

### 51. Сегментная организация памяти в защищенном режиме: принципы построения, схема получения линейного адреса

**Ответ:**  
Сегментная организация памяти в защищенном режиме используется для управления доступом к памяти и защиты данных. Каждая программа или процесс работает в рамках своих сегментов памяти, определяемых системой.

1. **Принципы построения**:  
   - Память разбивается на сегменты: код, данные, стек и т.д.  
   - Каждый сегмент имеет дескриптор, содержащий базовый адрес, размер и права доступа.  
   - Уровни привилегий (PL) контролируют доступ к сегментам.  

2. **Схема получения линейного адреса**:  
   - **Шаг 1**: Используя значение регистра сегмента (например, CS для сегмента кода), извлекается селектор.  
   - **Шаг 2**: Селектор указывает на запись в таблице дескрипторов (GDT или LDT).  
   - **Шаг 3**: Из дескриптора извлекаются базовый адрес и границы сегмента.  
   - **Шаг 4**: К базовому адресу сегмента прибавляется смещение (например, из регистра EIP для команд).  

Пример:  
Если регистр CS указывает на дескриптор сегмента с базовым адресом `0x4000`, а EIP содержит смещение `0x200`, линейный адрес будет равен `0x4200`.  

[К содержанию](#темы)

---

### 52. Защита памяти на уровне сегментов

**Ответ:**  
Защита памяти на уровне сегментов обеспечивает изоляцию процессов и предотвращает несанкционированный доступ.  

1. **Механизмы защиты**:  
   - Каждый сегмент имеет уровень привилегий (PL).  
   - Уровень привилегий текущего кода (CPL) сравнивается с привилегиями сегмента (DPL) и запрашиваемого уровня (RPL).  
   - Доступ разрешён только, если `CPL ≤ DPL` и `RPL ≤ DPL`.  

2. **Пример защиты**:  
   - Программы пользователя (PL=3) не могут напрямую обращаться к сегментам ядра (PL=0).  
   - Попытка записи в сегмент с правами только для чтения вызывает исключение.  

[К содержанию](#темы)

---

### 53. Страничная организация памяти: назначение, принципы построения, схема получения физического адреса

**Ответ:**  
Страничная организация памяти используется для управления большим адресным пространством и эффективного использования памяти.  

1. **Назначение**:  
   - Разделение адресного пространства на страницы фиксированного размера (обычно 4 КБ).  
   - Возможность подкачки страниц между ОЗУ и диском для экономии памяти.  

2. **Принципы построения**:  
   - Логический адрес делится на три части: номер каталога, номер страницы и смещение.  
   - Каталог страниц (Page Directory) указывает на таблицу страниц (Page Table), где хранятся физические адреса страниц.  
   - Если страница отсутствует в памяти, происходит исключение (page fault), и страница загружается из диска.  

3. **Схема получения физического адреса**:  
   - **Шаг 1**: Каталог страниц (TABLE) указывает на таблицу страниц.  
   - **Шаг 2**: Таблица страниц (PAGE) указывает на физический адрес страницы.  
   - **Шаг 3**: К физическому адресу прибавляется смещение (OFFSET).  

Пример:  
Если адрес состоит из `TABLE=0x3`, `PAGE=0x4`, `OFFSET=0x100`, а таблица страниц указывает на базовый адрес `0x2000`, физический адрес будет равен `0x2000 + 0x100 = 0x2100`.  

[К содержанию](#темы)

---

### 54. Защита памяти на уровне страниц

**Ответ:**  
Защита памяти на уровне страниц предотвращает несанкционированный доступ к данным на уровне отдельных страниц, а также контролирует права доступа.  

1. **Механизмы защиты**:  
   - Каждая страница имеет атрибуты:  
     - **R/W** (Read/Write): доступ только на чтение или чтение/запись.  
     - **U/S** (User/Supervisor): доступ только для режима супервизора или для всех режимов.  
   - Уровень привилегий сегмента (CPL) определяет доступ к страницам:  
     - CPL=0, 1, 2 — режим супервизора.  
     - CPL=3 — режим пользователя.  

2. **Особенности защиты**:  
   - Если страница доступна только для чтения, попытка записи вызовет исключение.  
   - Режим супервизора игнорирует флаг `R/W`, но доступ к страницам уровня пользователя ограничивается.  

3. **Пример применения**:  
   - ОС защищает свои данные, размещая их на страницах уровня супервизора.  
   - Программы пользователя размещаются на страницах уровня пользователя, чтобы они не могли модифицировать данные ОС.  

[К содержанию](#темы)

---

### 55. Управление задачами

**Ответ:**  
Управление задачами — это процесс переключения между задачами процессора для эффективного использования ресурсов системы.  

1. **Ситуации переключения задач**:  
   - **Программное переключение**: текущая задача вызывает переключение посредством команды, обращаясь к селектору задачи.  
   - **Прерывания и исключения**: процессор переключается на другую задачу для обработки события, например, аппаратных прерываний.  
   - **Возврат из задачи (IRET)**: переключение происходит при завершении текущей задачи и возврате к предыдущей.  

2. **Механизмы управления задачами**:  
   - **TSS (Task State Segment)**: специальный сегмент, в котором хранятся все данные, необходимые для выполнения задачи (регистры, указатели стека и т.д.).  
   - **Шлюз задачи**: используется для косвенного переключения задач. Хранит ссылку на дескриптор задачи в таблице сегментов.  

3. **Дескрипторы TSS**:  
   - Хранятся только в глобальной таблице дескрипторов (GDT).  
   - Определяют адреса и атрибуты TSS.  

**Пример работы**:  
Когда процессор переключается на новую задачу, он сохраняет текущее состояние регистров в TSS текущей задачи, а затем загружает соответствующие значения из TSS новой задачи.  

[К содержанию](#темы)

---

### 56. Прерывания и исключения: источники, порядок обработки

**Ответ:**  
Прерывания и исключения позволяют процессору реагировать на внешние и внутренние события.  

1. **Источники прерываний**:  
   - **Внешние сигналы**: запросы от устройств ввода-вывода (например, клавиатура, мышь).  
   - **Программные вызовы**: инструкции `INT n`, которые вызывают обработчики прерываний.  
   - **Исключения**: ошибки или особые случаи во время выполнения программы (например, деление на ноль).  

2. **Типы исключений**:  
   - **Нарушение (Fault)**: обнаруживается до выполнения команды (например, ошибка доступа к памяти).  
   - **Ловушка (Trap)**: обнаруживается после выполнения команды (например, переполнение).  
   - **Авария (Abort)**: приводит к завершению программы из-за невозможности продолжения.  

3. **Порядок обработки**:  
   - Процессор сохраняет текущие значения регистров в стек.  
   - Определяет источник прерывания или исключения.  
   - Обращается к таблице прерываний (в реальном режиме — таблица вектора прерываний, в защищённом режиме — дескрипторная таблица прерываний).  
   - Выполняет соответствующий обработчик.  

**Пример**:  
Если устройство ввода-вывода отправляет запрос прерывания, процессор сохраняет состояние текущей задачи, выполняет обработчик прерывания, а затем возвращается к выполнению прерванной программы.  

[К содержанию](#темы)

---

### 57. Организация таблицы прерываний в реальном и защищённом режимах работы процессора

**Ответ:**  
Таблица прерываний организована по-разному в реальном и защищённом режимах процессора.

1. **В реальном режиме**:  
   - **Таблица векторов прерываний**: располагается по фиксированному адресу (0x0000:0x0000).  
   - Каждое прерывание имеет вектор, соответствующий 4 байтам:  
     - 2 байта для сегмента CS (кодовый сегмент).  
     - 2 байта для смещения IP (указатель команды).  
   - Всего доступно 256 векторов (0–255).  

2. **В защищённом режиме**:  
   - Используется **дескрипторная таблица прерываний (IDT)**.  
   - Каждое прерывание представлено 8-байтовым дескриптором, включающим:  
     - Базовый адрес обработчика.  
     - Уровень привилегий.  
     - Тип дескриптора (ловушка, прерывание, шлюз задачи).  
   - Таблица IDT адресуется с помощью регистра IDTR, который указывает базовый адрес и размер таблицы.  

**Пример**:  
В защищённом режиме прерывание с вектором 0x21 (обработка клавиатуры) указывает на дескриптор в IDT. Этот дескриптор содержит базовый адрес обработчика события.  

[К содержанию](#темы)

---

### 58. Стратегии замещения страниц в памяти

**Ответ:**  
Стратегии замещения страниц определяют, какая страница будет выгружена из оперативной памяти при её переполнении.  

1. **Алгоритмы замещения**:  
   - **FIFO (First In First Out)**:  
     - Первая загруженная страница будет выгружена первой.  
     - Прост в реализации, но может приводить к частым заменам активных страниц.  
   - **LRU (Least Recently Used)**:  
     - Выгружается страница, которая дольше всего не использовалась.  
     - Требует хранения временных меток или списка использования страниц.  
   - **NFU (Not Frequently Used)**:  
     - Каждой странице присваивается счётчик обращений. Страница с наименьшим счётчиком выгружается.  
     - Реализуется с использованием прерываний по времени.  
   - **Clock (алгоритм с часовым циклом)**:  
     - Для каждой страницы используется бит обращения.  
     - Страницы проходят по кругу, и те, кто не использовался, выгружаются.  

2. **Особенности реализации**:  
   - Для реализации LRU требуется сложная логика управления.  
   - Алгоритм Clock является компромиссом между производительностью и сложностью.  

**Пример работы LRU**:  
Если страницы `A`, `B`, `C` используются в последовательности `A, B, C, A, B, D`, то при замещении выгружается страница `C`, так как она использовалась дольше всех.  

[К содержанию](#темы)
